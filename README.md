# HPC_matrix_multi_GPU
 
В данном репозитории расположено решение лабораторной работы №0 Перемножение матриц.<br><br>
Задача: реализовать алгоритм перемножения матриц.<br>
Входные данные: 2 матрицы размером от 100х100 до 2000х2000 каждая.<br>
Выходные данные: проверка корректности перемножения + время вычисления<br>
Реализация должна содержать 2 функции перемножения матриц: на CPU и на GPU с применением CUDA.<br><br>
Для реализации данной задачи использовалась следующая аппаратная база:<br>
Центральный процессор: _Intel Xeon E5-2620 v3 @ 2,4 GHz._<br>
Оперативная память: _Kllisre DDR4, 2 × 8 GB, 1600 MHz, DualChannel._<br>
Графический процессор: _PALIT GTX 1650 SUPER, 4GB VRAM GDDR6._<br><br>
Поскольку дополнительных условий или ограничений на реализацию решения наложено не было я реализовывал данное решение в прямую (в лоб).<br>
В функции ядра (***matrixMult***) каждая нить вычисляет 1 элемент итоговой матрицы C. Индексы начала строки матрицы A и столбца матрицы B, а также индекс элемента матрицы C, куда и будет записан результат работы нити будем определять по индексам блока и нити можно определить . Стоит отметить, что минусом данного подхода является то, что элементы матриц A и B подгружаются N раз (поскольку матрицы имеют квадратную размерность) из глобальной памяти, которая имеет максимальный объем и минимальную скорость *"общения"*.<br>
В функции с именем (***matrixMultCPU***) описана реализации математического алгоритма матричного умножения для работы в памяти центрального процессора. <br><br>
Проверку корректности решения осуществляет функция (***checkMult***), она сравнивает решение полученное в результате вычислений на центральном и графическом процессорах.<br>
Если разность этих решений не превосходит заданной точности, то решение корректно, иначе что-то пошло не так и у нас проблемы Хьюстон.<br><br>
Поскольку в программе используется ввод с консоли, для чтения размерности массива, то функция (***readDoubleInt***) осуществляет проверку вводимой информации,
чтобы пользователь не мог вводить ничего, кроме чисел. Тут стоит отметить, что поскольку нам необходимо считывать размерность массива, то это должно быть целочисленное значение,
и поэтому значения типа xx.0, тоже будем считать за целочисленные поскольку у них дробная часть равна нулю.<br><br>
Поскольку размерности массивов велики (*от 100 до 2000*), то нецелесообразно предлагать пользователю вводить все эти данные с консоли, а просто генерировать случайные значения, которыми и заполнять исходные матрицы, что и делает функция (***generateRandMatrix***).<br>
Для просмотра результатов умножения можно использовать функцию (***printMatrix***), которая напечатает их нам в консоль.<br>
Рассмотрим результаты работы функций полученные в результате проведения эксперимента.
<br><br>
### Время работы и ускорение параллельного алгоритма
 Размерность матрицы | 128 |  512 | 1024 | 2048 
:----:|:----:|:----:|:----:|:----:
**Время работы <br /> алгоритма на CUDA, мс.**| 0,122 |  6,698 | 55,274 | 395,964 
**Время работы <br /> последовательного алгоритма, мс.**| 9,255 | 1053,114 | 10226,292 | 231367,093 
**Ускорение, раз**| 75,594 | 157,223 | 185,012  |  584,313 
<br>
Результаты работы

Просматривая полученные результаты не трудно заметить, что скорость выполнения программы на графическом процессоре значительно превосходит скорости выполнения на центральном процессоре. Объясняется это тем, алгоритм на графическом процессоре распараллеливается, что значительно ускоряет процесс вычислений, в то время как на центральном процессоре этот алгоритм выполняется последовательно, что при значительном увеличении размерности критически сказывается на скорости вычислений.<br>
Так же стоит отметить, что графический процессор обладает бОшльшими вычислительными возможностями нежели центральный. В моем случае графический процессор обладает 1280 ядрами CUDA, в то время как центральный всего лишь 6-ю, трудно не согласиться с огромными приростом вычислительных возможностей при использовании графического процессора.<br><br>
Подводя итоги хочется отметить, что графический профессор является отличным ускорителем при производстве вычислений, который позволяет значительно ускорить вычисления, что не трудно заметить по результатам полученным в ходе выполнения данной лабораторной работы.
